---
title: "PA2: Server Load"
---

<img src="./serverImg.jpg" style="float:right;max-width:40vw;border-radius:40px;margin-left:10px;border:3px solid black">

### Reminder: Policy Regarding GenAI

This is a friendly reminder on the class policy regarding the use of GenAI on programming assignments in this course. While you may use GenAI to **do the equivalent of looking up known information on the web / in a manual**, you may **NOT use GenAI to generate the solution to any part of this programming assignment**. The purpose of the assignment is to practice your problem solving and programming implementation skills on your own. If we find that you have copied significant code generated by AI for this programming assignment, this will be considered an honor violation.

&nbsp;  

### Introduction

You have been hired by the Data Synthesis Association (DSA), who needs you to analyze resource usage on its various servers and produce visualizations for engineers that can help them make decisions about how to be more efficient. 

The DSA has many customers who each have large amounts of servers, devices, and such on their networks. Each device has usage patterns that are given to you and the company is asking for you to write a program that computes several things about the data. First, some more information about the input:

- You will be given data for one single day.
- A client has a list of $n$ devices that it manages. Each device has a _string name identifier_
- With each devices comes a list of __usage periods__.
- Each __usage period__ is a three-tuple $(s,f,w)$ where $s$ is the start minute ($0 \leq s \leq 1440$) in the day, $f$ is the end minute ($0 \leq f \leq 1440$, $s < f$), and $w$ is the load (or weight) on that server during that period ($1-100$ percent as an integer). 
- For simplicity, each __usage period__ is presented as a flat average usage across that time period (the load/weight does not fluctuate within a single usage period).

Given a list of devices, and usage periods for each individual device, the company wants you to write a program that computes the following for them:

- The company wants a graph showing only the outline of the maximum usage periods over the course of the day. For example, at any minute $m$, the graph would show the percentage of the highest load device at minute $m$ only. This graph is a silhouette showing the maximum usage time devices and how maximum usage over all devices changes over time. The input/output format for this graph is shown below in example and in the input/output section.
- The company wants you to list the single device that is the maximum usage device for the most minutes on that day.
- The company wants you to list the single device that is the minimum usage device for the most minutes on that day.

&nbsp;  

### Example

Consider the following devices and usage periods:

![](exampleIn.png)

There are three devices: Server1, Server2, and Server3. The usage periods are shown, color-coded by specific server. Server1 has three different usage periods but Server2 and Server3 only have one each. The graph that the company wants you to compute is shown in the output figure below.

![](exampleOut.png)

Note that the company doesn't need you to print the image of the graph. They only need the points at which the maximum changes. So for this example, you would print $(100,20) (220,40) (700,70) (780,40) (1100,20) (1350,0)$. Each of these points represent a minute in which the maximum usage device changes and the new maximum load starting at that point. If there is a non-zero usage at minute 0, you should report that as you first change in your output.

In addition, the company wants the server that had the maximum/minimum number of minutes as the maximum load device. In this case:

- Server1 was the maximum from minute 100-220 and minute 1100-1350 for a total of 120+250=**370 minutes**.
- Server2 was the maximum from minute 220-700 and minute 780-1100 for a total of 480+320=**800 minutes**
- Server3 was the maximum from minute 700-780 for a total of **80 minutes**

So, you should report Server2 as being the highest load device for the longest amount of time and Server3 for being the highest load device for the least amount of time.

&nbsp;  

### Input description

There is only (and exactly) one test case per file.

The first line of the input file will contain the total number of devices $d$ that the client has, where $1 \le d \le 10^4$, followed by a space, followed by $u$ the number of usage periods between all of those devices ($1 \le u \le 10^6$).

The next $d$ lines will list the names of the devices in an arbitrary order.

The next $u$ lines will list the usage periods one at a time. Each usage pattern will be four space-separated values: The name of the device, start time $0 \le s \le 1440$, finish time $0 \le f \le 1440$, and usage load $1 \le w \le 100$. It will always be the case that $s < f$.

&nbsp;  

### Output description

For each test case, output the list of points that trace along the silhouette of usage periods in order from left to right (see example above for detail). Use the format in the example below. There should be one space between each point (it's fine if there is an extra space at the end of that line). On the next line, name the single device that was at the largest load for the most minutes followed by a space followed by the number of minutes this device was the maximum load device. On the next line do the same but for the device with the fewest minutes as the max load device. If there are any ties, report the device that reaches the maximum / minimum number of minutes earliest in the day.

&nbsp;  

### Sample input



```
3 5
Server1
Server2
Server3
Server1 1000 1350 20
Server1 100 310 20
Server3 700 780 70
Server2 220 1100 40
Server1 560 850 20
```

&nbsp;  

### Sample output

```
(100,20) (220,40) (700,70) (780,40) (1100,20) (1350,0)
Server2 800
Server3 80
```

&nbsp;  

### Skeleton Code

We are providing skeleton code for this assignment.  You should start with [pa2.py](pa2.py.html) or [PA2.java](PA2.java.html).  This code only reads in the input described above.

&nbsp;  

### Implementation Notes

- This **must be a divide-and-conquer solution**
- When you submit your code, the test case shown above will be run to ensure your program is handling the input and output correctly.
- Your program needs to run in $\Theta(n log n)$ time. In order to achieve this, you will need to calculate the graph points using a _divide and conquer_ algorithm.
- If two usage periods overlap, then they are guaranteed to have different load percentages. This avoids some annoying edge cases that we don't want you to have to deal with.
- We will never provide you with invalid input, so you do not need to error check the input values provided.
- This implementation is a little bit tricky, and we will not see how to do it in lecture. The section below (implementation hints) will summarize the overall approach you should take. 

&nbsp;  

### Implementation Hints

Your first task should be to find the points along the silhouette of usage periods. In order to do this you should use a **divide and conquer** approach. You do NOT need to pre-sort the usage periods in order for this to work. You should:

- Make sure to think through what the base case is. What is the set of points denoting the silhouette of a single usage period?
- Divide the usage periods in half
- Recursively find the silhouette of the left periods and right periods (again, they do not need to be pre-sorted)
- Take the silhouette points of the left periods and merge them with the silhouette periods of the right half (more detail on how in a moment).

The trickiest part of this algorithm is how to actually merge two sets of points that represent the silhouette of two different portions of the usage periods. The two recursive calls should return a list of silhouette points in sorted order from smallest x-coordinate to largest x-coordinate. Let's call these _leftSol_ and _rightSol_. Recall that each set of points is a list of x-coordinates and heights. You can merge these by doing the following:

- Start an index pointer at the first point (first index) of _leftSol_ and another at the first point (first index) of _rightSol_. The overall idea is we are going to "crawl" across the points in x-coordinate order (smallest to largest) and keep track of which of our two silhouettes is larger as we go.
- You are always keeping track of the largest height (from the left index or right index) as you go. For the next index (whichever has a smaller x-coordinate):
	- Calculate the new height at this x-coordinate
	- Check this new height against the height of the other side to get the maximum
	- If the maximum height has changed, report that there is a new "point" on our merged silhouette
	- *HINT: Two cases you should think about. 1) If the left and right points have the same height, what do you do? 2) Think about the first point that gets added. The merge is using two heights to find the maximum but at some point at the beginning only one of those two will have an actual value. Keep that in mind.*

Once you have the silhouette points being returned correctly, then think about how to update your code to also keep track of which device is at the maximum at each step. Good luck!

&nbsp;  

### Submission

The submission system can handle four different programming languages, although only two have skeleton code provided (Python and Java).  For each programming language, the name of the submitted file is listed below (you have to have it named that exact name, else it will not compile properly).  If you want to program in a different language, email the course email at least three days before it is due (as we have to reconfigure the autograder).

- Python 3: pa2.py
- Java: PA2.java
- C: pa2.c
- C++: pa2.cpp

You will submit your completed source code file to Gradescope.  There will be a *small set* of acceptance tests that are ***NOT COMPREHENSIVE***.  These acceptance tests are the test cases in the [example.in](example.in) file.  It's up to you to comprehensively test your code.  The acceptance tests just verify that you are reading the input correctly and providing the expected output.

Note that when you submit, Gradescope will report your grade as "-/10" or "0/10" -- that's a quirk of Gradescope, and is because the grading tests have not been run (and won't be run until after all submissions are in).  You can look at the results of the individual test cases to see how your program worked
